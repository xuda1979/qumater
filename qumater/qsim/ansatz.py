"""Variational ansÃ¤tze inspired by hardware-agnostic quantum compilation."""
from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, Sequence

import numpy as np


def _rotation_y(theta: float) -> np.ndarray:
    c = np.cos(theta / 2.0)
    s = np.sin(theta / 2.0)
    return np.array([[c, -s], [s, c]], dtype=complex)


def _rotation_z(theta: float) -> np.ndarray:
    return np.array(
        [[np.exp(-1j * theta / 2.0), 0.0], [0.0, np.exp(1j * theta / 2.0)]],
        dtype=complex,
    )


def _rotation_y_derivative(theta: float) -> np.ndarray:
    half = theta / 2.0
    return np.array(
        [
            [-0.5 * np.sin(half), -0.5 * np.cos(half)],
            [0.5 * np.cos(half), -0.5 * np.sin(half)],
        ],
        dtype=complex,
    )


def _rotation_z_derivative(theta: float) -> np.ndarray:
    half = theta / 2.0
    return np.array(
        [
            [(-0.5j) * np.exp(-1j * half), 0.0],
            [0.0, (0.5j) * np.exp(1j * half)],
        ],
        dtype=complex,
    )


def _apply_single_qubit_gate(state: np.ndarray, gate: np.ndarray, qubit: int, num_qubits: int) -> np.ndarray:
    state_t = state.reshape([2] * num_qubits)
    state_t = np.moveaxis(state_t, qubit, 0)
    state_t = np.tensordot(gate, state_t, axes=[1, 0])
    state_t = np.moveaxis(state_t, 0, qubit)
    return state_t.reshape(-1)


def _apply_cz(state: np.ndarray, control: int, target: int, num_qubits: int) -> np.ndarray:
    if control == target:
        raise ValueError("Control and target qubits must be distinct")
    shape = [2] * num_qubits
    state_t = state.reshape(shape)
    slicer = [slice(None)] * num_qubits
    slicer[control] = 1
    slicer[target] = 1
    state_t[tuple(slicer)] *= -1.0
    return state_t.reshape(-1)


@dataclass
class HardwareAgnosticAnsatz:
    """Hardware-agnostic low-depth ansatz.

    The Tencent report highlights Phasecraft's *hardware-agnostic* circuits that
    can be compiled onto different quantum backends with minimal depth
    inflation.  We emulate this concept by alternating layers of parameterised
    single qubit rotations with sparse entangling gates arranged in a ring.  The
    ansatz keeps gate counts modest yet expressive enough for strongly
    correlated benchmarks such as the 2x2 Fermi-Hubbard model referenced in the
    article.
    """

    num_qubits: int
    layers: int = 1

    def __post_init__(self) -> None:
        if self.num_qubits < 1:
            raise ValueError("num_qubits must be positive")
        if self.layers < 1:
            raise ValueError("layers must be positive")

    @property
    def parameter_count(self) -> int:
        """Return the number of continuous parameters required by the ansatz."""

        return self.num_qubits * self.layers * 2

    def prepare_state(self, parameters: Sequence[float]) -> np.ndarray:
        """Return the state vector generated by the ansatz.

        Parameters
        ----------
        parameters:
            Sequence of rotation angles.  Two angles per qubit per layer are
            expected (``RY`` and ``RZ`` rotations respectively).
        """

        parameters = list(parameters)
        if len(parameters) != self.parameter_count:
            raise ValueError(
                f"Expected {self.parameter_count} parameters, received {len(parameters)}"
            )

        state = np.zeros(2**self.num_qubits, dtype=complex)
        state[0] = 1.0

        index = 0
        for _ in range(self.layers):
            for qubit in range(self.num_qubits):
                theta = parameters[index]
                phi = parameters[index + 1]
                index += 2
                state = _apply_single_qubit_gate(state, _rotation_y(theta), qubit, self.num_qubits)
                state = _apply_single_qubit_gate(state, _rotation_z(phi), qubit, self.num_qubits)

            for qubit in range(self.num_qubits):
                target = (qubit + 1) % self.num_qubits
                if target == qubit:
                    continue
                state = _apply_cz(state, qubit, target, self.num_qubits)

        norm = np.linalg.norm(state)
        if norm == 0:
            raise RuntimeError("Ansatz produced the zero vector")
        return state / norm

    def parameter_gradient(self, parameters: Sequence[float]) -> np.ndarray:
        """Return the analytic gradient of the prepared state's amplitudes.

        We differentiate the circuit exactly by inserting the derivative of the
        corresponding rotation matrix at the position of each parameterised
        gate.  This mirrors the adjoint differentiation strategy used in modern
        quantum simulators and avoids the numerical instabilities that
        accompany finite-difference estimators.
        """

        parameters = np.asarray(parameters, dtype=float)
        if parameters.size != self.parameter_count:
            raise ValueError(
                f"Expected {self.parameter_count} parameters, received {parameters.size}"
            )

        dim = 2**self.num_qubits
        grads = np.zeros((self.parameter_count, dim), dtype=complex)

        operations: list[tuple[str, int, float | int]] = []
        parameter_positions: list[int] = []
        index = 0
        for _ in range(self.layers):
            for qubit in range(self.num_qubits):
                theta = parameters[index]
                operations.append(("ry", qubit, float(theta)))
                parameter_positions.append(len(operations) - 1)
                index += 1

                phi = parameters[index]
                operations.append(("rz", qubit, float(phi)))
                parameter_positions.append(len(operations) - 1)
                index += 1

            for qubit in range(self.num_qubits):
                target = (qubit + 1) % self.num_qubits
                if target == qubit:
                    continue
                operations.append(("cz", qubit, target))

        for grad_index, op_index in enumerate(parameter_positions):
            state = np.zeros(dim, dtype=complex)
            state[0] = 1.0
            for idx, operation in enumerate(operations):
                op_type, qubit, value = operation
                if op_type == "ry":
                    gate = _rotation_y(value)
                    if idx == op_index:
                        gate = _rotation_y_derivative(value)
                    state = _apply_single_qubit_gate(state, gate, qubit, self.num_qubits)
                elif op_type == "rz":
                    gate = _rotation_z(value)
                    if idx == op_index:
                        gate = _rotation_z_derivative(value)
                    state = _apply_single_qubit_gate(state, gate, qubit, self.num_qubits)
                else:  # "cz"
                    state = _apply_cz(state, qubit, int(value), self.num_qubits)
            grads[grad_index] = state

        return grads


__all__ = ["HardwareAgnosticAnsatz"]
